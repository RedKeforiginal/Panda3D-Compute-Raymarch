#version 430 core

//================================================================================
// Panda3D Compute Shader Raymarcher - Intersection Pass
//================================================================================
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 0) writeonly uniform image2D positionImage;
layout(rgba32f, binding = 1) writeonly uniform image2D normalImage;

uniform vec3 camera_pos;
uniform mat4 cam_to_world;
uniform mat4 proj_mat;

uniform int   u_max_primary_steps;
uniform float u_max_dist;
const float SURF_DIST = 0.0005;

float epsilon(float t) { return t * 0.0001 > SURF_DIST ? t * 0.0001 : SURF_DIST; }

#include "SDF.glsl"

vec3 getNormal(vec3 p) {
    vec3 n = vec3(0.0);
    const vec3 offsets[8] = vec3[](
        vec3(1,1,1), vec3(-1,1,1), vec3(1,-1,1), vec3(-1,-1,1),
        vec3(1,1,-1), vec3(-1,1,-1), vec3(1,-1,-1), vec3(-1,-1,-1)
    );
    for(int i=0;i<8;++i){
        vec3 e = offsets[i] * SURF_DIST;
        n += offsets[i] * map(p + e);
    }
    return normalize(n);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(positionImage);
    if (pixel.x >= size.x || pixel.y >= size.y) return;

    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);
    vec2 ndc = vec2(uv.x, 1.0 - uv.y) * 2.0 - 1.0;
    vec3 dir_cam_space = vec3(ndc.x / proj_mat[0][0], ndc.y / proj_mat[1][1], -1.0);
    vec3 ro = camera_pos;
    vec3 rd = normalize((cam_to_world * vec4(dir_cam_space, 0.0)).xyz);

    float t = 0.0;
    for (int i = 0; i < u_max_primary_steps; ++i) {
        vec3 p = ro + rd * t;
        float d = map(p);
        if (d < epsilon(t)) {
            vec3 n = getNormal(p);
            imageStore(positionImage, pixel, vec4(p, 1.0));
            imageStore(normalImage, pixel, vec4(n, 1.0));
            return;
        }
        t += d;
        if (t > u_max_dist) break;
    }

    imageStore(positionImage, pixel, vec4(0.0));
    imageStore(normalImage, pixel, vec4(0.0));
}
