#version 430


layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 0) writeonly uniform image2D outputImage;

uniform mat4 inv_view_proj;
uniform vec3 camera_pos;
uniform float time;

const int MAX_STEPS = 128;
const float MAX_DIST = 100.0;
const float EPSILON = 0.001;

// Signed distance function
float lattice(vec3 p){
    // Repeat space.
    vec3 q = abs(mod(p, vec3(32, 16, 32)) - vec3(16, 8, 16));
    vec3 q2 = abs(mod(p - vec3(4, 0, 0), vec3(32, 2, 16)) - vec3(16, 1, 8));

    // Holes. I've called them holes, but they're more like square columns used to negate objects.
    float hole1 = max(q2.x - 7.65, q.z - 8.); // Used to carve a hole beside the railings.
    float hole2 = max(-p.y - .75, q.z - 4.85); // Used to chop the top off of the bridge railings.
    float hole3 = abs(mod(p.z + 16., 32.) - 16.) - 2.85; // Used to form the floor to ceiling partitions.

    // Floor minus hole (repeat square columns) equals bridge. :)
    float fl = max(p.y + 3.5, -hole1);

    // The wall panels with rectangular windows.
    float wall = max(q2.x - 8., q2.z - 2.15);
    wall = max(wall, -max(abs(abs(q2.x - 8.) - 4.) - 1.75, abs(q.y - 8.) - .5)); // Wall with window.

    // This is a neat trick to subdivide space up further without the need for another
    // modulo call... in a manner of speaking.
    q2.x = abs(q2.x - 8.);
    float rail = max(q2.x - .15, q2.y - .15);
    float rail2 = max(q2.x - .15/6., abs(mod(q2.y + 1./6., 1./3.) - 1./6.) - .15/6.);
    rail = min(rail, max(rail2, -p.y - 3.));
    // Optional bottom rail with no gap. Comment out the line above though.
    //rail = min(min(rail, rail2), max(q2.x - .15, abs(p.y + 3.75) - .6));

    // Posts.
    float posts = max(q2.x - .15, abs(mod(q2.z, 2.) - 1.) - .15);

    // Forming the railings. Comment out the 2nd and 3rd lines if you want to see what they're there for.
    rail = min(rail, posts);
    rail = max(rail, -hole2);
    rail = max(rail, -hole3);

    // Subdividing space down again without using the modulo call. For all I know, I've made things
    // slower. :)
    q.xz = abs(q.xz - vec2(8));
    q.x = abs(q.x - 4.);

    // Pylons and round pylons.
    float pylon = min( max(max(q.x, q.y) - 3., -p.y) , min(max(q.y, q.z)*.55 + length(q.yz)*.45 - 3.1,
                  max(q.x, q.z)) - 2.);
    float rndPylon = length(vec2(q.xz)*vec2(.7, .4)) - 1.;

    // Breaking space right down to 2x2x2 cubic segments.
    q = abs(mod(q,  2.) - 1.);
    float pylonHole = min(q.x, min(q.y, q.z)); // Used to take cubic chunks out of the pylons.

    // Forming the structure.
    float structure = min(max(pylon, pylonHole) - .15, min(rndPylon, wall));

    // Adding the floor and the railings to the structure.
    return min(structure, min(fl, rail));
}
float map(vec3 p) {
    return lattice(p);
}

vec3 get_normal(vec3 p) {
    const vec2 e = vec2(0.001, 0.0);
    return normalize(vec3(
        map(p + e.xyy) - map(p - e.xyy),
        map(p + e.yxy) - map(p - e.yxy),
        map(p + e.yyx) - map(p - e.yyx)
    ));
}

vec4 shade(vec3 p, vec3 n) {
    vec3 light_dir = normalize(vec3(1.0, 1.0, 1.0));
    float diff = max(dot(n, light_dir), 0.0);
    return vec4(vec3(diff), 1.0);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);
    if (pixel.x >= size.x || pixel.y >= size.y) {
        return;
    }

    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);
    vec4 near_pt = inv_view_proj * vec4(uv * 2.0 - 1.0, 0.0, 1.0);
    vec4 far_pt = inv_view_proj * vec4(uv * 2.0 - 1.0, 1.0, 1.0);

    vec3 ro = camera_pos;
    vec3 rd = normalize((far_pt.xyz / far_pt.w) - (near_pt.xyz / near_pt.w));

    float t = 0.0;
    float dist = 0.0;
    for (int i = 0; i < MAX_STEPS; ++i) {
        vec3 pos = ro + rd * t;
        dist = map(pos);
        if (dist < EPSILON || t > MAX_DIST) {
            break;
        }
        t += dist;
    }

    vec4 color = vec4(0.0);
    if (dist < EPSILON) {
        vec3 pos = ro + rd * t;
        vec3 n = get_normal(pos);
        color = shade(pos, n);
    }

    imageStore(outputImage, pixel, color);
}
