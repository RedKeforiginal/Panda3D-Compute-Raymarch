#version 430


layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 0) writeonly uniform image2D outputImage;

uniform mat4 inv_view_proj;
uniform vec3 camera_pos;
uniform float time;
uniform vec3 u_color;        // Base color of the material
uniform float u_roughness;   // Perceptual roughness in [0,1]
uniform float u_R0;          // Reflectance at normal incidence
uniform vec3 u_light_spacing; // Spacing of the point light grid
uniform vec3 u_light_offset;  // Offset of the point light grid
uniform vec3 u_light_color;   // Radiance/color of each point light

layout(binding = 1) uniform sampler2D albedo_tex;
layout(binding = 2) uniform sampler2D roughness_tex;
const int MAX_STEPS = 128;
const float MAX_DIST = 100.0;
const float EPSILON = 0.001;
const float PI = 3.14159265359;

// Signed distance function
float lattice(vec3 p){
    // Repeat space.
    vec3 q = abs(mod(p, vec3(32, 16, 32)) - vec3(16, 8, 16));
    vec3 q2 = abs(mod(p - vec3(4, 0, 0), vec3(32, 2, 16)) - vec3(16, 1, 8));

    // Holes. I've called them holes, but they're more like square columns used to negate objects.
    float hole1 = max(q2.x - 7.65, q.z - 8.); // Used to carve a hole beside the railings.
    float hole2 = max(-p.y - .75, q.z - 4.85); // Used to chop the top off of the bridge railings.
    float hole3 = abs(mod(p.z + 16., 32.) - 16.) - 2.85; // Used to form the floor to ceiling partitions.

    // Floor minus hole (repeat square columns) equals bridge. :)
    float fl = max(p.y + 3.5, -hole1);

    // The wall panels with rectangular windows.
    float wall = max(q2.x - 8., q2.z - 2.15);
    wall = max(wall, -max(abs(abs(q2.x - 8.) - 4.) - 1.75, abs(q.y - 8.) - .5)); // Wall with window.

    // This is a neat trick to subdivide space up further without the need for another
    // modulo call... in a manner of speaking.
    q2.x = abs(q2.x - 8.);
    float rail = max(q2.x - .15, q2.y - .15);
    float rail2 = max(q2.x - .15/6., abs(mod(q2.y + 1./6., 1./3.) - 1./6.) - .15/6.);
    rail = min(rail, max(rail2, -p.y - 3.));
    // Optional bottom rail with no gap. Comment out the line above though.
    //rail = min(min(rail, rail2), max(q2.x - .15, abs(p.y + 3.75) - .6));

    // Posts.
    float posts = max(q2.x - .15, abs(mod(q2.z, 2.) - 1.) - .15);

    // Forming the railings. Comment out the 2nd and 3rd lines if you want to see what they're there for.
    rail = min(rail, posts);
    rail = max(rail, -hole2);
    rail = max(rail, -hole3);

    // Subdividing space down again without using the modulo call. For all I know, I've made things
    // slower. :)
    q.xz = abs(q.xz - vec2(8));
    q.x = abs(q.x - 4.);

    // Pylons and round pylons.
    float pylon = min( max(max(q.x, q.y) - 3., -p.y) , min(max(q.y, q.z)*.55 + length(q.yz)*.45 - 3.1,
                  max(q.x, q.z)) - 2.);
    float rndPylon = length(vec2(q.xz)*vec2(.7, .4)) - 1.;

    // Breaking space right down to 2x2x2 cubic segments.
    q = abs(mod(q,  2.) - 1.);
    float pylonHole = min(q.x, min(q.y, q.z)); // Used to take cubic chunks out of the pylons.

    // Forming the structure.
    float structure = min(max(pylon, pylonHole) - .15, min(rndPylon, wall));

    // Adding the floor and the railings to the structure.
    return min(structure, min(fl, rail));
}
float map(vec3 p) {
    return lattice(p);
}

vec3 get_normal(vec3 p) {
    const vec2 e = vec2(0.001, 0.0);
    return normalize(vec3(
        map(p + e.xyy) - map(p - e.xyy),
        map(p + e.yxy) - map(p - e.yxy),
        map(p + e.yyx) - map(p - e.yyx)
    ));
}

// ---- Physically based shading helpers ----
float DistributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;
    float denom = NdotH2 * (a2 - 1.0) + 1.0;
    return a2 / (PI * denom * denom);
}

float GeometrySchlickGGX(float NdotV, float k) {
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float k) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2 = GeometrySchlickGGX(NdotV, k);
    float ggx1 = GeometrySchlickGGX(NdotL, k);
    return ggx1 * ggx2;
}

vec3 FresnelSchlick(float cosTheta, float R0) {
    return vec3(R0) + (vec3(1.0 - R0)) * pow(1.0 - cosTheta, 5.0);
}
vec3 sample_albedo(vec3 p) {
    vec2 uv = p.xz * 0.05;
    return texture(albedo_tex, uv).rgb;
}

float sample_roughness(vec3 p) {
    vec2 uv = p.xz * 0.05;
    return texture(roughness_tex, uv).r;
}


vec4 shade(vec3 p, vec3 n) {
    vec3 V = normalize(camera_pos - p);
    vec3 base_color = sample_albedo(p);
    float roughness = sample_roughness(p);

    vec3 color = vec3(0.0);
    vec3 base = floor((p - u_light_offset) / u_light_spacing + 0.5) * u_light_spacing + u_light_offset;
    for(int ix=-1; ix<=1; ++ix){
        for(int iy=-1; iy<=1; ++iy){
            for(int iz=-1; iz<=1; ++iz){
                vec3 light_pos = base + vec3(ix,iy,iz) * u_light_spacing;
                vec3 Lvec = light_pos - p;
                float dist2 = dot(Lvec, Lvec);
                vec3 L = normalize(Lvec);

                float NdotL = max(dot(n, L), 0.0);
                float NdotV = max(dot(n, V), 0.0);
                vec3 H = normalize(V + L);
                float VdotH = max(dot(V, H), 0.0);

                float D = DistributionGGX(n, H, roughness);
                float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
                float G = GeometrySmith(n, V, L, k);
                vec3 F = FresnelSchlick(VdotH, u_R0);

                vec3 numerator = D * G * F;
                float denominator = max(4.0 * NdotV * NdotL, 0.001);
                vec3 specular = numerator / denominator;

                vec3 kd = (vec3(1.0) - F);
                vec3 diffuse = kd * (base_color / PI);

                float attenuation = 1.0 / dist2;
                vec3 radiance = u_light_color * attenuation * NdotL;
                color += (diffuse + specular) * radiance;
            }
        }
    }
    return vec4(color, 1.0);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);
    if (pixel.x >= size.x || pixel.y >= size.y) {
        return;
    }

    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);
    vec4 near_pt = inv_view_proj * vec4(uv * 2.0 - 1.0, -1.0, 1.0);
    vec4 far_pt = inv_view_proj * vec4(uv * 2.0 - 1.0, 1.0, 1.0);

    // Rays originate from the near plane as required for orthographic lenses (see docs.gl).
    vec3 ro = near_pt.xyz / near_pt.w;
    vec3 rd = normalize((far_pt.xyz / far_pt.w - (near_pt.xyz / near_pt.w)));

    float t = 0.0;
    float dist = 0.0;
    for (int i = 0; i < MAX_STEPS; ++i) {
        vec3 pos = ro + rd * t;
        dist = map(pos);
        if (dist < EPSILON || t > MAX_DIST) {
            break;
        }
        t += dist;
    }

    vec4 color = vec4(0.0);
    if (dist < EPSILON) {
        vec3 pos_sdf = ro + rd * t;
        vec3 n_sdf = get_normal(pos_sdf);
        vec3 pos = pos_sdf;
        vec3 n = normalize(n_sdf);
        color = shade(pos, n);
    }

    imageStore(outputImage, pixel, color);
}
