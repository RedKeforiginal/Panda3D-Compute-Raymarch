#version 430 core

//================================================================================================
// Panda3D Compute Shader Raymarcher - v2 (Corrected)
//================================================================================================

//------------------------------------------------------------------------------------------------
// IO and Layout
//------------------------------------------------------------------------------------------------
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba32f, binding = 0) writeonly uniform image2D outputImage;

//------------------------------------------------------------------------------------------------
// Uniforms (Inputs from Python)
//------------------------------------------------------------------------------------------------
// Camera Data for Manual Ray Construction
uniform vec3 camera_pos;       // Camera position in world space (Ray Origin)
uniform mat4 cam_to_world;     // Camera's world matrix (rotates Ray Direction)
uniform mat4 proj_mat;         // Projection matrix (to extract Field of View)

uniform float time;

// Lighting
uniform vec3 u_light_spacing;
uniform vec3 u_light_offset;
uniform vec3 u_light_color;

// PBR Material Properties
// Albedo and roughness are computed procedurally now, leaving only the
// reflectance parameter. See the GLSL uniform rules in the spec:
// https://docs.gl/gl4/glUniform
uniform float u_R0; // Reflectance at normal incidence (typically ~0.04 for dielectrics)


//------------------------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------------------------
const float PI = 3.14159265359;
const int MAX_STEPS = 128;
const float MAX_DIST = 100.0;
const float SURF_DIST = 0.001;

//================================================================================================
// Scene Definition (Signed Distance Function)
//================================================================================================
float lattice(vec3 p) {
    vec3 q = abs(mod(p, vec3(32, 16, 32)) - vec3(16, 8, 16));
    vec3 q2 = abs(mod(p - vec3(4, 0, 0), vec3(32, 2, 16)) - vec3(16, 1, 8));
    float hole1 = max(q2.x - 7.65, q.z - 8.);
    float hole2 = max(-p.y - .75, q.z - 4.85);
    float hole3 = abs(mod(p.z + 16., 32.) - 16.) - 2.85;
    float fl = max(p.y + 3.5, -hole1);
    float wall = max(q2.x - 8., q2.z - 2.15);
    wall = max(wall, -max(abs(abs(q2.x - 8.) - 4.) - 1.75, abs(q.y - 8.) - .5));
    q2.x = abs(q2.x - 8.);
    float rail = max(q2.x - .15, q2.y - .15);
    float rail2 = max(q2.x - .15/6., abs(mod(q2.y + 1./6., 1./3.) - 1./6.) - .15/6.);
    rail = min(rail, max(rail2, -p.y - 3.));
    float posts = max(q2.x - .15, abs(mod(q2.z, 2.) - 1.) - .15);
    rail = min(rail, posts);
    rail = max(rail, -hole2);
    rail = max(rail, -hole3);
    q.xz = abs(q.xz - vec2(8));
    q.x = abs(q.x - 4.);
    float pylon = min( max(max(q.x, q.y) - 3., -p.y) , min(max(q.y, q.z)*.55 + length(q.yz)*.45 - 3.1, max(q.x, q.z)) - 2.);
    float rndPylon = length(vec2(q.xz)*vec2(.7, .4)) - 1.;
    q = abs(mod(q,  2.) - 1.);
    float pylonHole = min(q.x, min(q.y, q.z));
    float structure = min(max(pylon, pylonHole) - .15, min(rndPylon, wall));
    return min(structure, min(fl, rail));
}

float map(vec3 p) { return lattice(p); }

vec3 getNormal(vec3 p) {
    vec3 n = vec3(0.0);
    for(int i=0; i<4; ++i){
        vec3 e = 0.5773 * (2.0 * vec3(float((i+3)>>1 & 1), float((i>>1) & 1), float(i & 1)) - 1.0);
        n += e * map(p + e * SURF_DIST);
    }
    return normalize(n);
}

//================================================================================================
// PBR, Lighting, and Shadowing
//================================================================================================
float DistributionGGX(vec3 N, vec3 H, float r) { float a2=r*r*r*r; float nH=max(dot(N,H),0.); return a2/(PI*pow(nH*nH*(a2-1.)+1.,2.)); }
float GeometrySchlickGGX(float nV, float r) { float k=(r+1.)*(r+1.)/8.; return nV/(nV*(1.-k)+k); }
float GeometrySmith(vec3 N, vec3 V, vec3 L, float r) { return GeometrySchlickGGX(max(dot(N,V),0.),r)*GeometrySchlickGGX(max(dot(N,L),0.),r); }
vec3 fresnelSchlick(float c, vec3 F0) { return F0+(vec3(1.)-F0)*pow(clamp(1.-c,0.,1.),5.);}
float calcSoftshadow(vec3 ro, vec3 rd, float mint, float tmax) {
    float res = 1.0;
    float t = mint;
    for(int i=0; i<24; ++i){
        float h = map(ro + rd * t);
        res = min(res, 8.0*h / t);
        t += clamp(h, 0.02, 0.1);
        if(res < 0.005 || t > tmax) break;
    }
    return clamp(res, 0.0, 1.0);
}

float calcAO(vec3 pos, vec3 nor) {
    float occ = 0.0;
    float sca = 1.0;
    for(int i=0; i<5; ++i){
        float h = 0.01 + 0.12*float(i)/4.0;
        float d = map(pos + nor*h);
        occ += (h - d) * sca;
        sca *= 0.95;
    }
    return clamp(1.0 - 3.0*occ, 0.0, 1.0);
}

float calculateShadow(vec3 ro, vec3 rd, float max_t) {
    float t = 0.01;
    for (int i = 0; i < 48; ++i) {
        float h = map(ro + rd * t);
        if (h < SURF_DIST) return 0.0;
        t += h;
        if (t > max_t) break;
    }
    return 1.0;
}

// Value noise based on a simple hash; this avoids repeating patterns.
float hash3(vec3 p) {
    return fract(sin(dot(p, vec3(12.9898, 78.233, 37.719))) * 43758.5453);
}

float noise3(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    vec3 u = f*f*(3.0-2.0*f);
    float n000 = hash3(i + vec3(0,0,0));
    float n100 = hash3(i + vec3(1,0,0));
    float n010 = hash3(i + vec3(0,1,0));
    float n110 = hash3(i + vec3(1,1,0));
    float n001 = hash3(i + vec3(0,0,1));
    float n101 = hash3(i + vec3(1,0,1));
    float n011 = hash3(i + vec3(0,1,1));
    float n111 = hash3(i + vec3(1,1,1));
    float nx00 = mix(n000, n100, u.x);
    float nx10 = mix(n010, n110, u.x);
    float nx01 = mix(n001, n101, u.x);
    float nx11 = mix(n011, n111, u.x);
    float nxy0 = mix(nx00, nx10, u.y);
    float nxy1 = mix(nx01, nx11, u.y);
    return mix(nxy0, nxy1, u.z);
}

float fbm3(vec3 p) {
    float v = 0.0;
    float a = 0.5;
    for (int i = 0; i < 5; ++i) {
        v += a * noise3(p);
        p *= 2.0;
        a *= 0.5;
    }
    return v;
}

vec4 calculateColor(vec3 p, vec3 n, vec3 V) {

    // Procedural marble based on 3D fBm noise
    float noiseVal = fbm3(p * 0.2);
    float m = sin(p.y * 0.3 + noiseVal * 3.0);
    vec3 albedo = mix(vec3(0.2, 0.2, 0.25), vec3(0.9, 0.9, 0.95), m);
    float roughness = 0.3 + 0.2 * noiseVal;


    // PBR properties for a non-metallic surface
    float metallic = 0.0;
    vec3 F0 = vec3(u_R0);
    float ao = calcAO(p, n);

    // Accumulate lighting from a 3x3x3 grid of point lights
    vec3 Lo = vec3(0.0); // Final outgoing radiance
    vec3 light_grid_base = floor((p - u_light_offset) / u_light_spacing + 0.5) * u_light_spacing + u_light_offset;

    for (int ix = -1; ix <= 1; ++ix) {
        for (int iy = -1; iy <= 1; ++iy) {
            for (int iz = -1; iz <= 1; ++iz) {
                vec3 light_pos = light_grid_base + vec3(ix, iy, iz) * u_light_spacing;
                vec3 L = normalize(light_pos - p);
                float light_dist = length(light_pos - p);
                float attenuation = 1.0 / (light_dist * light_dist);
                vec3 radiance = u_light_color * attenuation;
                vec3 H = normalize(V + L);
                float NdotL = max(dot(n, L), 0.0);
                
                if (NdotL > 0.0) {
                    float shadow = calcSoftshadow(p + n * SURF_DIST * 2.0, L, 0.02, light_dist);
                    if (shadow > 0.0) {
                        float NDF = DistributionGGX(n, H, roughness);
                        float G = GeometrySmith(n, V, L, roughness);
                        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);

                        vec3 spec = (NDF * G * F) / (4.0 * max(dot(n,V),0.0) * NdotL + 0.001);
                        
                        // Correct kd calculation for energy conservation
                        vec3 kd = vec3(1.0) - F;
                        kd *= (1.0 - metallic);
                        
                        // Apply albedo to the diffuse component
                        vec3 diffuse = kd * albedo / PI;

                        Lo += (diffuse + spec) * radiance * NdotL;
                    }
                }
            }
        }
    }
    
vec3 color = Lo * ao;

    // HDR Tone Mapping and Gamma Correction
    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2));
    
    return vec4(color, 1.0);
}

//================================================================================================
// Main Entry Point
//================================================================================================
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);
    if (pixel.x >= size.x || pixel.y >= size.y) {
        return;
    }

    // --- FUNDAMENTALLY CORRECT RAY CONSTRUCTION ---
    // 1. Convert pixel coordinate to Normalized Device Coordinates (NDC) [-1, 1]
    //    The Y-coordinate is flipped to match GL's bottom-left origin.
    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);
    vec2 ndc = vec2(uv.x, 1.0 - uv.y) * 2.0 - 1.0;

    // 2. Create the ray direction in CAMERA-space.
    //    We use the FOV information stored in the projection matrix.
    //    Panda3D's Y-up projection matrix has the form:
    //    [1/tan(fovX/2), 0,             0,  0]
    //    [0,             1/tan(fovY/2), 0,  0]
    //    [...]
    //    So, we can find the camera-space direction by dividing NDC by these terms.
    vec3 dir_cam_space = vec3(ndc.x / proj_mat[0][0], ndc.y / proj_mat[1][1], -1.0);

    // 3. Define the Ray Origin and Direction in WORLD-space.
    //    Ray Origin (ro) is simply the camera's world position.
    //    Ray Direction (rd) is the camera-space direction rotated into world space.
    vec3 ro = camera_pos;
    vec3 rd = normalize((cam_to_world * vec4(dir_cam_space, 0.0)).xyz);

    // --- Primary Raymarch ---
    float t = 0.0;
    for (int i = 0; i < MAX_STEPS; ++i) {
        vec3 p = ro + rd * t;
        float d = map(p);
        if (d < SURF_DIST) {
            vec3 V = -rd;
            vec3 n = getNormal(p);
            imageStore(outputImage, pixel, calculateColor(p, n, V));
            return;
        }
        t += d;
        if (t > MAX_DIST) break;
    }

    imageStore(outputImage, pixel, vec4(0.0, 0.0, 0.0, 1.0));
}
